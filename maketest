#!/usr/bin/env python

""" Random test generation with content balancing. """

from subprocess import call
import argparse
import random
import string
import yaml

def maketest(bank_file, config_file, outfile='test', max_tries=10):
    """ Randomly generate a test from an item bank and a configuation file. The
    item bank associates one or more tags with each item. The configuration file
    specifies which items should be sampled using combinations of tags. Both the
    item bank and configuration files should be valid YAML files.

    Arguments:
        - bank_file: item bank file name
        - config_file: configuration file name
        - outfile: output file name, without extension
        - max_tries: maximum number of times to try to generate a test.
    """
    item_latex = write_item_latex(select_items(load_item_bank(bank_file),
                                               load_config(config_file),
                                               max_tries))
    # Create a PDF for the test
    create_test_pdf(item_latex, outfile, show_key=False)
    # Create a PDF with the answer key shown to facilitate grading
    create_test_pdf(item_latex, outfile, show_key=True)


def load_item_bank(bank_file):
    """ Load an item bank.
    """
    with open(bank_file, 'r') as the_file:
        item_bank = yaml.load(the_file)
    for item, entry in enumerate(item_bank):
        item_bank[item]['tags'] = set(entry['tags'])
    return item_bank

def load_config(config_file):
    """ Load a configuration file.
    """
    with open(config_file, 'r') as the_file:
        config = yaml.load(the_file)
    config['exclude'] = set(config['exclude'])
    return config

def select_items(item_bank, config, max_tries):
    """ Sample test items in the numbers specified by the configuration file. Currently,
    if the sampler is unable to complete a test (because it runs out of items for some
    tag), it restarts from the begining of the test.
    """
    tries = 0
    test_items = []
    while not test_items:
        if tries == max_tries:
            msg = "Tried to assemble the test %d times. " % max_tries
            msg = "%sIncrease 'max_tries' or check configuration file." % msg
            raise AssertionError(msg)
        avail = set(range(len(item_bank)))
        for tag, num in config['include'].items():
            useable = [item for item in avail
                       if tag in item_bank[item]['tags']
                       and not bool(config['exclude'] & item_bank[item]['tags'])]
            if len(useable) < num:
                test_items = []
                tries += 1
                break
            for _ in range(num):
                item = random.choice(useable)
                useable.remove(item)
                avail.remove(item)
                test_items.append(item)
    return [item_bank[item] for item in test_items]

def write_item_latex(test):
    r""" Write out the LaTeX code for test items. Produces output like the following
    example:

    \question ...insert the item text from item['text']...
    \begin{choices}
        \CorrectChoice ...text in item['responses'][0]...
        \choice ...text in item['responses'][1]...
        ...etc...
    \end{choices}
    """
    choices_template = '\\begin{choices}\n %s\n \\end{choices}\n'
    item_latex = []
    for item in test:
        question_text = '\\question %s' % item['text']
        responses = []
        for (i, resp) in enumerate(item['responses']):
            if i == item['correct'] - 1:
                responses.append('\\CorrectChoice %s' % resp)
            else:
                responses.append('\\choice %s' % resp)
        response_text = choices_template % '\n'.join(responses)
        item_latex.append('\n'.join([question_text, response_text]))
    return '\n'.join(item_latex)

def create_test_pdf(item_latex, outfile, show_key=False):
    """ Write the latex code given the item text.
    """
    if show_key:
        docclass_opts = '[answers]'
        latex_file = outfile + '_and_key.tex'
    else:
        docclass_opts = ''
        latex_file = outfile + '.tex'
    latex_code = latex_template().substitute({'docclass_opts': docclass_opts,
                                              'questions': item_latex})
    with open(latex_file, 'w') as the_file:
        the_file.write(latex_code)
    return call(['pdflatex', latex_file])

def latex_template():
    """ Template for writing LaTeX code from item code. """
    return string.Template(
        r"""\documentclass$docclass_opts{exam}

        \begin{document}
            \begin{center}
                {\large \textbf{PYSC 2010, Research Methods Midterm, Spring 2017}}
            \end{center}

            \vspace{0.2in}
            \makebox[\textwidth]{Name:\enspace\hrulefill}
            \vspace{.4in}

            \begin{center}
                \fbox{\fbox{\parbox{5.5in}{\centering
                    Answer the questions in the spaces provided on the
                    question sheets.  If you run out of room for an answer,
                    continue on the back of the page.}}}
            \end{center}

            \vspace{.3in}

            \begin{questions}
                $questions
            \end{questions}
        \end{document}""")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Randomly generate a test from an item bank.",
        epilog="""Tests are defined by a list of tags. Every item in the item bank is
        assigned one or more tags. The configuration file defines which items should be
        included in the test using these tags. Every entry in the configuration specifies
        a set of possible items using their tags and specifies how many of those items
        should be included in the test.""")
    parser.add_argument('bank_file', help='YAML file containing the item bank')
    parser.add_argument('config_file',
                        help='configuration YAML file defining test structure')
    parser.add_argument('-o', '--outfile', default='test',
                        help='name of the output file, without extension')
    parser.add_argument('--max_tries', default=10,
                        help='maximum number of times to try to generate a test')
    args = vars(parser.parse_args())
    maketest(**args)
